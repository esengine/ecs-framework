/**
 * Auto-generated Worker file for PhysicsWorkerSystem
 * 自动生成的 Worker 文件
 *
 * Source: F:/ecs-framework/examples/wechat-worker-demo/src/systems/PhysicsWorkerSystem.ts
 * Generated by @esengine/worker-generator
 *
 * 使用方式 | Usage:
 * 1. 将此文件放入 workers/ 目录
 * 2. 在 game.json 中配置 "workers": "workers"
 * 3. 在 System 中配置 workerScriptPath: 'workers/physics-worker-system-worker.js'
 */

// 微信小游戏 Worker 环境
// WeChat Mini Game Worker environment
let sharedFloatArray = null;
const ENTITY_DATA_SIZE = 9;

worker.onMessage(function(res) {
    // 微信小游戏 Worker 消息直接传递数据，不需要 .data
    // WeChat Mini Game Worker passes data directly, no .data wrapper
    var type = res.type;
    var id = res.id;
    var entities = res.entities;
    var deltaTime = res.deltaTime;
    var systemConfig = res.systemConfig;
    var startIndex = res.startIndex;
    var endIndex = res.endIndex;
    var sharedBuffer = res.sharedBuffer;

    try {
        // 处理 SharedArrayBuffer 初始化
        // Handle SharedArrayBuffer initialization
        if (type === 'init' && sharedBuffer) {
            sharedFloatArray = new Float32Array(sharedBuffer);
            worker.postMessage({ type: 'init', success: true });
            return;
        }

        // 处理 SharedArrayBuffer 数据
        // Handle SharedArrayBuffer data
        if (type === 'shared' && sharedFloatArray) {
            processSharedArrayBuffer(startIndex, endIndex, deltaTime, systemConfig);
            worker.postMessage({ id: id, result: null });
            return;
        }

        // 传统处理方式
        // Traditional processing
        if (entities) {
            var result = workerProcess(entities, deltaTime, systemConfig);

            // 处理 Promise 返回值
            // Handle Promise return value
            if (result && typeof result.then === 'function') {
                result.then(function(finalResult) {
                    worker.postMessage({ id: id, result: finalResult });
                }).catch(function(error) {
                    worker.postMessage({ id: id, error: error.message });
                });
            } else {
                worker.postMessage({ id: id, result: result });
            }
        }
    } catch (error) {
        worker.postMessage({ id: id, error: error.message });
    }
});

/**
 * 实体处理函数 - 从 PhysicsWorkerSystem.workerProcess 提取
 * Entity processing function - extracted from PhysicsWorkerSystem.workerProcess
 */
function workerProcess(entities, deltaTime, config) {
    var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var gravity = config.gravity;
var canvasWidth = config.canvasWidth;
var canvasHeight = config.canvasHeight;
var groundFriction = config.groundFriction;
// 复制实体数组避免修改原数据
// Copy entity array to avoid modifying original data
var result = entities.map(function (e) { return (__assign({}, e)); });
// 物理更新
// Physics update
for (var i = 0; i < result.length; i++) {
    var entity = result[i];
    // 应用重力
    // Apply gravity
    entity.dy += gravity * deltaTime;
    // 更新位置
    // Update position
    entity.x += entity.dx * deltaTime;
    entity.y += entity.dy * deltaTime;
    // 边界碰撞
    // Boundary collision
    if (entity.x <= entity.radius) {
        entity.x = entity.radius;
        entity.dx = -entity.dx * entity.bounce;
    }
    else if (entity.x >= canvasWidth - entity.radius) {
        entity.x = canvasWidth - entity.radius;
        entity.dx = -entity.dx * entity.bounce;
    }
    if (entity.y <= entity.radius) {
        entity.y = entity.radius;
        entity.dy = -entity.dy * entity.bounce;
    }
    else if (entity.y >= canvasHeight - entity.radius) {
        entity.y = canvasHeight - entity.radius;
        entity.dy = -entity.dy * entity.bounce;
        entity.dx *= groundFriction;
    }
    // 空气阻力
    // Air friction
    entity.dx *= entity.friction;
    entity.dy *= entity.friction;
}
// 简单碰撞检测
// Simple collision detection
for (var i = 0; i < result.length; i++) {
    for (var j = i + 1; j < result.length; j++) {
        var ball1 = result[i];
        var ball2 = result[j];
        var dx = ball2.x - ball1.x;
        var dy = ball2.y - ball1.y;
        var distance = Math.sqrt(dx * dx + dy * dy);
        var minDistance = ball1.radius + ball2.radius;
        if (distance < minDistance && distance > 0) {
            // 分离两个球
            // Separate two balls
            var nx = dx / distance;
            var ny = dy / distance;
            var overlap = minDistance - distance;
            ball1.x -= nx * overlap * 0.5;
            ball1.y -= ny * overlap * 0.5;
            ball2.x += nx * overlap * 0.5;
            ball2.y += ny * overlap * 0.5;
            // 弹性碰撞
            // Elastic collision
            var relVx = ball2.dx - ball1.dx;
            var relVy = ball2.dy - ball1.dy;
            var velAlongNormal = relVx * nx + relVy * ny;
            if (velAlongNormal > 0)
                continue;
            var restitution = (ball1.bounce + ball2.bounce) * 0.5;
            var impulse = -(1 + restitution) * velAlongNormal / (1 / ball1.mass + 1 / ball2.mass);
            ball1.dx -= impulse * nx / ball1.mass;
            ball1.dy -= impulse * ny / ball1.mass;
            ball2.dx += impulse * nx / ball2.mass;
            ball2.dy += impulse * ny / ball2.mass;
        }
    }
}
return result;

}

/**
 * SharedArrayBuffer 处理函数
 * SharedArrayBuffer processing function
 */
function processSharedArrayBuffer(startIndex, endIndex, deltaTime, systemConfig) {
    if (!sharedFloatArray) return;
    // No SharedArrayBuffer processing defined
}
